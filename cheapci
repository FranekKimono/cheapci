#!/bin/bash

# Simple CI

set -o pipefail

function show_help() {
	cat > /dev/stdout << END
$0 [-q <pre-script>] [-w <post-script>] [-m <email>] [-n name] [-d <dir>] [-c <command>] [-f] [-v] [-h] -r <repo> -l <local_checkout>

-q - script to run just before actually performing test (default /bin/true)
-w - script to run just after actually performing test (default /bin/true)
-m - email to send using "mail" command (default logs to stdout)
-n - name for ci (unique, must be a valid directory name), eg myproj (default=ci)
-d - directory within repository to navigate to (default=.)
-c - test command to run from -d directory (default=./test.sh)
-f - force a run even if repo has no updates (default off)
-v - verbose logging (default off)
-h - show help
-r - git repository, eg https://github.com/myname/myproj (required)
-l - local checkout of code (that gets updated to determine whether a run is needed) (required)
END
}

# Defaults
FORCE=0
VERBOSE=0
REPO=""
EMAIL=""
NAME="ci"
TEST_DIR="."
TEST_COMMAND="./test.sh"
MAIL_CMD="mail"
PRE_SCRIPT="/bin/true"
POST_SCRIPT="/bin/true"

while getopts "h?vfm:n:d:r:l:c:a:q:w" opt
do
	case "$opt" in
	h|\?)
		show_help
		exit 0
		;;
	v)
		VERBOSE=1
		;;
	f)
		FORCE=1
		;;
	r)
		REPO=$OPTARG
		;;
	m)
		EMAIL=$OPTARG
		;;
	n)
		NAME=$OPTARG
		;;
	d)
		TEST_DIR=$OPTARG
		;;
	l)
		LOCAL_CHECKOUT=$OPTARG
		;;
	c)
		TEST_COMMAND=$OPTARG
		;;
	a)
		MAIL_CMD=$OPTARG
		;;
	q)
		PRE_SCRIPT=$OPTARG
		;;
	w)
		POST_SCRIPT=$OPTARG
		;;
	esac
done

shift $((OPTIND-1))

if [[ $REPO = "" ]]
then
	show_help
	exit 1
fi


# To force a run even if no updates.

if [[ $VERBOSE -gt 0 ]]
then
	set -x
fi

BUILD_DIR_BASE="/tmp/${NAME}"
BUILD_DIR="${BUILD_DIR_BASE}/${NAME}_builddir"
mkdir -p $BUILD_DIR
LOG_FILE="${BUILD_DIR}/${NAME}_build_${RANDOM}.log.txt"
BUILD_LOG_FILE="${BUILD_DIR}/${NAME}_build.log.txt"
LOCK_FILE="${BUILD_DIR}/${NAME}ci.lck"

function cleanup() {
	rm -rf ${BUILD_DIR}/${NAME}
	rm -f ${LOCK_FILE}
	# get rid of /tmp detritus, leaving anything accessed 2 days ago+
	find ${BUILD_DIR_BASE}/* -type d -atime +1 | rm -rf
	echo cleanup	
	exit 1
}

trap cleanup TERM INT QUIT

function send_mail() {
	msg=$1
	if [[ $EMAIL != "" ]] && [[ $MAIL_CMD != "" ]]
	then
		echo $msg | $MAIL_CMD -s "$msg" -A $LOG_FILE -t $EMAIL
	else
		echo $msg
	fi
}

echo $(date) 2>&1 | tee -a $BUILD_LOG_FILE

# Lockfile
if [[ -a $LOCK_FILE ]]
then
	echo "Already running" | tee -a $BUILD_LOG_FILE
	exit 
else
	touch $LOCK_FILE
	# Fetch changes
	pushd $LOCAL_CHECKOUT
	git fetch origin master 2>&1 | tee -a $BUILD_LOG_FILE
	# See if there are any incoming changes
	updates=$(git log HEAD..origin/master --oneline | wc -l)
	echo "Updates: $updates" | tee -a $BUILD_LOG_FILE
	if [[ $updates -gt 0 ]] || [[ $FORCE -gt 0 ]]
	then
		touch $LOG_FILE
		pushd $LOCAL_CHECKOUT
		echo "Pulling" | tee -a $LOG_FILE
		git pull origin master 2>&1 | tee -a $LOG_FILE
		popd
		# This won't exist in a bit so no point pushd'ing
		pushd $BUILD_DIR
		# Clone to NAME
		git clone $REPO $NAME
		popd
		eval $PRE_SCRIPT | tee -a ${LOG_FILE} 2>&1
		EXIT_CODE=$?
	        if [[ $EXIT_CODE -ne 0 ]]
		then
			msg="ANGRY $NAME"
		fi
		pushd ${BUILD_DIR}/${NAME}/${TEST_DIR}
		$TEST_COMMAND | tee -a ${LOG_FILE} 2>&1
		EXIT_CODE=$?
		popd
	        if [[ $EXIT_CODE -ne 0 ]]
		then
			msg="ANGRY $NAME"
		else
			msg="HAPPY $NAME"
		fi
		eval $POST_SCRIPT | tee -a ${LOG_FILE} 2>&1
		EXIT_CODE=$?
	        if [[ $EXIT_CODE -ne 0 ]]
		then
			msg="ANGRY $NAME"
		fi
		send_mail $msg
	fi
	cleanup
fi
